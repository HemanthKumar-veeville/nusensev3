<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>nusense</title>

    <link rel="icon" href="./icons8-creative-64.png" type="image/x-icon" />

    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@900&family=Lobster&family=Poppins:wght@800&family=Pacifico&family=Raleway:wght@900&display=swap"
      rel="stylesheet"
    />

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
        font-family: monospace;
      }

      #canvas {
        position: fixed;
        top: 0;
        left: 0;
        z-index: 1;
      }

      .title {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-size: 72px;
        font-weight: bold;
        z-index: 2;
        text-shadow: 0 0 10px rgba(255, 255, 255, 0.5),
          0 0 15px rgba(255, 255, 255, 0.3);
        pointer-events: none;
        opacity: 0.7;
        transition: opacity 1s ease-in-out;
        font-family: "Roboto", sans-serif;
        user-select: none;
      }

      .hidden {
        opacity: 0;
      }

      @media (max-width: 1200px) {
        .title {
          font-size: 60px;
        }
      }

      @media (max-width: 800px) {
        .title {
          font-size: 48px;
        }
      }

      @media (max-width: 600px) {
        .title {
          font-size: 36px;
        }
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <div class="title" id="title">NUSENSE</div>

    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const title = document.getElementById("title");

      let textVisible = true;
      let currentFormation = "circle";
      let mouse = { x: undefined, y: undefined };
      // Add this variable at the top with other variables
      let lastInteractionTime = 0;
      const resetDelay = 2000; // 2 seconds without interaction before reset

      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resize();
      window.addEventListener("resize", resize);

      function getShapeVertices(sides, width, height) {
        const baseSize = Math.min(width, height) * 0.4;
        const size = baseSize * 1.25;
        const centerX = width / 2;
        const centerY = height / 2;
        const angleStep = (2 * Math.PI) / sides;
        const rotationOffset = -Math.PI / 2;

        const vertices = [];
        for (let i = 0; i < sides; i++) {
          vertices.push({
            x: centerX + size * Math.cos(i * angleStep + rotationOffset),
            y: centerY + size * Math.sin(i * angleStep + rotationOffset),
          });
        }
        return vertices;
      }

      function getShapeVerticesByFormation(formation, width, height) {
        switch (formation) {
          case "circle":
            return getShapeVertices(32, width, height);
          case "triangle":
            return getShapeVertices(3, width, height);
          case "square":
            return getShapeVertices(4, width, height);
          case "pentagon":
            return getShapeVertices(5, width, height);
          case "hexagon":
            return getShapeVertices(6, width, height);
          case "heptagon":
            return getShapeVertices(7, width, height);
          case "octagon":
            return getShapeVertices(8, width, height);
          case "nonagon":
            return getShapeVertices(9, width, height);
          case "decagon":
            return getShapeVertices(10, width, height);
          default:
            return getShapeVertices(3, width, height);
        }
      }

      class Particle {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.targetX = x;
          this.targetY = y;
          this.vx = (Math.random() - 0.5) * 1;
          this.vy = (Math.random() - 0.5) * 1;
          this.radius = 1.5;
          this.color = `hsla(${Math.random() * 360}, 50%, 50%, 0.8)`;
          this.speed = Math.random() * 0.5 + 0.5;
          this.angle = Math.random() * Math.PI * 2;
          this.wobble = Math.random() * Math.PI * 2;
        }

        update(mouseX, mouseY) {
          this.wobble += 0.05;

          if (mouseX !== undefined && mouseY !== undefined) {
            const dx = mouseX - this.x;
            const dy = mouseY - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const maxDistance = 150;

            if (distance < maxDistance) {
              const angle = Math.atan2(dy, dx);
              this.targetX =
                mouseX + Math.cos(angle) * (50 + Math.sin(this.wobble) * 20);
              this.targetY =
                mouseY + Math.sin(angle) * (50 + Math.sin(this.wobble) * 20);
            } else {
              this.targetX = this.x + Math.cos(this.angle) * 100;
              this.targetY = this.y + Math.sin(this.angle) * 100;
            }
          } else if (!textVisible) {
            const textX = canvas.width / 2;
            const textY = canvas.height / 2;
            const dx = textX - this.x;
            const dy = textY - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < 200) {
              this.targetX = textX + (Math.random() - 0.5) * 50;
              this.targetY = textY + (Math.random() - 0.5) * 50;
            }
          } else {
            this.angle += 0.02;
            const distanceFromCenter = 200 + Math.sin(this.wobble) * 50;

            if (currentFormation === "circle") {
              this.targetX =
                canvas.width / 2 + Math.cos(this.angle) * distanceFromCenter;
              this.targetY =
                canvas.height / 2 + Math.sin(this.angle) * distanceFromCenter;
            } else {
              const shapeVertices = getShapeVerticesByFormation(
                currentFormation,
                canvas.width,
                canvas.height
              );
              const totalLength = shapeVertices.length;
              const anglePerSegment = (Math.PI * 2) / totalLength;
              const segment =
                Math.floor(this.angle / anglePerSegment) % totalLength;
              const nextSegment = (segment + 1) % totalLength;
              const segmentProgress =
                (this.angle % anglePerSegment) / anglePerSegment;

              const currentVertex = shapeVertices[segment];
              const nextVertex = shapeVertices[nextSegment];

              this.targetX =
                currentVertex.x * (1 - segmentProgress) +
                nextVertex.x * segmentProgress;
              this.targetY =
                currentVertex.y * (1 - segmentProgress) +
                nextVertex.y * segmentProgress;
            }
          }

          this.x += (this.targetX - this.x) * 0.05 * this.speed;
          this.y += (this.targetY - this.y) * 0.05 * this.speed;

          this.x += Math.sin(this.wobble) * 0.5;
          this.y += Math.cos(this.wobble) * 0.5;

          if (this.x < 0) this.x = canvas.width;
          if (this.x > canvas.width) this.x = 0;
          if (this.y < 0) this.y = canvas.height;
          if (this.y > canvas.height) this.y = 0;
        }

        draw() {
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fillStyle = this.color;
          ctx.fill();
        }
      }

      const numParticles = Math.floor(
        (window.innerWidth * window.innerHeight) / 1000
      );
      const particles = [];
      for (let i = 0; i < numParticles; i++) {
        particles.push(
          new Particle(
            Math.random() * canvas.width,
            Math.random() * canvas.height
          )
        );
      }

      function animate() {
        ctx.fillStyle = "rgba(0,0,0,0.05)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        particles.forEach((particle) => {
          particle.update(mouse.x, mouse.y);
          particle.draw();
        });

        requestAnimationFrame(animate);
      }
      animate();

      canvas.addEventListener("mousemove", (e) => {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
      });

      canvas.addEventListener("mouseout", () => {
        mouse.x = undefined;
        mouse.y = undefined;
      });

      window.addEventListener("resize", () => {
        resize();
        const newParticleCount = Math.floor(
          (window.innerWidth * window.innerHeight) / 1000
        );
        while (particles.length < newParticleCount) {
          particles.push(
            new Particle(
              Math.random() * canvas.width,
              Math.random() * canvas.height
            )
          );
        }
        particles.length = newParticleCount;
      });

      // After line 289 (after the mouseout event listener), add these event listeners:

      canvas.addEventListener("touchmove", (e) => {
        e.preventDefault(); // Prevent scrolling while touching canvas
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        mouse.x = touch.clientX - rect.left;
        mouse.y = touch.clientY - rect.top;
        lastInteractionTime = Date.now();
      });

      canvas.addEventListener("touchend", () => {
        mouse.x = undefined;
        mouse.y = undefined;
        lastInteractionTime = Date.now();
      });

      canvas.addEventListener("touchcancel", () => {
        mouse.x = undefined;
        mouse.y = undefined;
        lastInteractionTime = Date.now();
      });

      const fonts = [
        "'Lobster', cursive",
        "'Poppins', sans-serif",
        "'Roboto', sans-serif",
        "'Raleway', sans-serif",
      ];

      let fontIndex = 0;
      function changeFont() {
        title.classList.add("hidden");
        textVisible = false;

        setTimeout(() => {
          fontIndex = (fontIndex + 1) % fonts.length;
          title.style.fontFamily = fonts[fontIndex];
          title.classList.remove("hidden");
          textVisible = true;
        }, 1000);
      }

      function toggleFormation() {
        const formations = [
          "circle",
          "triangle",
          "square",
          "pentagon",
          "hexagon",
          "heptagon",
          "octagon",
          "nonagon",
          "decagon",
        ];
        const currentIndex = formations.indexOf(currentFormation);
        currentFormation = formations[(currentIndex + 1) % formations.length];
      }

      setInterval(changeFont, 6000);
      setInterval(toggleFormation, 6000);
    </script>
  </body>
</html>
